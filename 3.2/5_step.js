/**
 * Создает функцию, которая возвращает функцию, использующую замыкание для
 * выполнения повторяемого сложения матрицы 2x2.
 *
 * @param {number[][]} addMatrix матрица 2x2 для сложения в формате [[a, b], [c, d]]
 *
 * @returns {function} функция, которая принимает матрицу 2x2, возвращает
 *  результат сложения матриц в формате [[a, b], [c, d]]
 */
function addMatrix2d(addMatrix) {
  return function (matrix) {
    return [
      [matrix[0][0] + addMatrix[0][0], matrix[0][1] + addMatrix[0][1]],
      [matrix[1][0] + addMatrix[1][0], matrix[1][1] + addMatrix[1][1]],
    ];
  };
}

/**
 * Создает функцию, которая возвращает функцию, использующую замыкание для
 * выполнения повторяемого умножения матрицы 2x2 на скалярное значение.
 *
 * @param {number} scalar скалярное значение для умножения
 *
 * @returns {function} функция, которая принимает матрицу 2x2, возвращает
 *  результат умножения матрицы на скаляр в формате [[a, b], [c, d]]
 */
function multiplyScalar2d(scalar) {
  return function (matrix) {
    return [
      [matrix[0][0] * scalar, matrix[0][1] * scalar],
      [matrix[1][0] * scalar, matrix[1][1] * scalar],
    ];
  };
}

/**
 * Возвращает функцию, которая мемоизирует последний результат. Если аргументы
 * такие же, как при последнем вызове, то возвращается мемоизированный результат.
 *
 * @param {function} f функция трансформации для мемоизации, предполагается, что принимает матрицу 2x2
 *
 * @returns {function} функция, которая принимает матрицу 2x2 и либо возвращает сохраненный результат,
 *  если аргументы совпадают с предыдущими вызовами, либо вычисляет новый результат, если они отличаются
 */
function memoizeMatrixTransform(f) {
  // Переменные для хранения последних аргументов и результата
  let lastArgs = null;
  let lastResult = null;

  return function (matrix) {
    // Проверяем, совпадают ли аргументы с последним вызовом
    // Для матрицы 2x2 нам нужно сравнить все 4 элемента
    if (
      lastArgs !== null &&
      lastArgs[0][0] === matrix[0][0] &&
      lastArgs[0][1] === matrix[0][1] &&
      lastArgs[1][0] === matrix[1][0] &&
      lastArgs[1][1] === matrix[1][1]
    ) {
      // Аргументы совпадают - возвращаем кэшированный результат
      return lastResult;
    }

    // Аргументы отличаются или это первый вызов
    // Вычисляем новый результат
    lastResult = f(matrix);

    // Сохраняем копию аргументов для будущих сравнений
    // Важно сохранить копию, а не ссылку!
    lastArgs = [
      [matrix[0][0], matrix[0][1]],
      [matrix[1][0], matrix[1][1]],
    ];

    return lastResult;
  };
}
